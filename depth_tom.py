# Combine RGB and Mask for generating Inpaint Mask
import cv2
import numpy as np

# mask image
path_mask = "/home/ayush/OptiDepth/MirrorNet/ckpt/MirrorNet/MirrorNet_160_nocrf/m2..png"
mask = cv2.imread(path_mask)
inv_mask = cv2.bitwise_not(mask)
_, mask_thresh = cv2.threshold(inv_mask, 127, 255, cv2.THRESH_BINARY)
kernel = np.ones((5, 5), np.uint8) 
dilated_mask = cv2.dilate(mask_thresh, kernel, iterations=1)
border = cv2.bitwise_xor(dilated_mask, mask_thresh)

# rgb image
path_rgb ="./MiDaS/input/m2.jpeg"
rgb = cv2.imread(path_rgb)
print(rgb.shape)

# midas image
path_midas_depth = "./MiDaS/output/m2-openvino_midas_v21_small_256.png"
midas_depth = cv2.imread(path_midas_depth)
# Scale depth to get relative depth
d_min = np.min(midas_depth)
d_max = np.max(midas_depth)
depth_relative = (midas_depth - d_min) / (d_max - d_min)

# Color it
depth_relative = np.array(depth_relative) * 255
depth_relative = depth_relative.astype(np.uint8)
depth_relative = cv2.applyColorMap(depth_relative, cv2.COLORMAP_INFERNO)

print(midas_depth.shape)

# Apply Bitwise AND to MiDas output(depth_relative) and (Mask generated by MirrorNet)
final = cv2.bitwise_or(rgb, mask)
mask_ = mask
mask_[np.where((mask_>[127, 127, 127]).all(axis=-1))] = (0, 255, 255)    
final = cv2.addWeighted(rgb, 0.7, mask_, 0.3, 0)
final_ = cv2.bitwise_and(depth_relative, mask_thresh)
# Extract palette
mask_gray = cv2.cvtColor(mask, cv2.COLOR_RGB2GRAY)
inpaint = cv2.inpaint(final_, mask_gray , 20, flags=cv2.INPAINT_TELEA)
cv2.imwrite("/home/ayush/Downloads/mask_bw.png", final)


Hori = np.concatenate((rgb,depth_relative, mask, final, inpaint), axis=1)
cv2.namedWindow("Corrected Depth", cv2.WINDOW_NORMAL)
cv2.resizeWindow("Corrected Depth", 1000, 500)
cv2.imshow("Corrected Depth", Hori)
k = cv2.waitKey(0) & 0xFF
if k == 27:  # close on ESC key
    cv2.destroyAllWindows()
